// ==============================================================
// VALIDATE APP COMPLEXITY â€“ AGGREGATED SUMMARY TABLE
// ==============================================================
// This read-only query rolls up the flow-level story-point metrics
// (generated by story-points-complexity-analysis.cypher) to the
// MuleApp level.  Each row represents one application with
// high-level delivery metrics useful for portfolio planning and
// executive reporting.
// ==============================================================

// 1) Collect all analysed Flows per application
MATCH (app:MuleApp)-[:HAS_FLOW]->(flow:Flow)
WHERE flow.finalStoryPoints IS NOT NULL   // only flows that have been analysed
WITH app, collect(flow) AS flows

// 2) Derive core numeric aggregates from flow properties
WITH app, flows,
     size(flows)                                                    AS flowCount,
     reduce(s = 0, f IN flows | s + coalesce(f.finalStoryPoints,0)) AS totalStoryPoints,
     round(reduce(s = 0, f IN flows | s + coalesce(f.finalStoryPoints,0)) * 1.0 / size(flows), 1) AS avgStoryPoints,
     reduce(s = 0, f IN flows | s + coalesce(f.connectorCount,0))   AS totalConnectorCount,
     reduce(s = 0, f IN flows | s + coalesce(f.asyncIndicatorCount,0)) AS totalAsyncIndicators,
     reduce(s = 0, f IN flows | s + (CASE WHEN f.isAsyncFlow THEN 1 ELSE 0 END)) AS asyncFlows,
     reduce(s = 0, f IN flows | s + (CASE WHEN f.isApiExposed THEN 1 ELSE 0 END)) AS apiExposedFlows,
     reduce(s = 0, f IN flows | s + coalesce(f.apiKitRouteCount,0)) AS totalApiKitRoutes,
     reduce(s = 0, f IN flows | s + coalesce(f.apiKitCount,0))      AS totalApiKits,
     reduce(s = 0, f IN flows | s + (CASE WHEN f.riskFlags >= 3 THEN 1 ELSE 0 END)) AS highRiskFlows

// 3) Application-level Connector nodes
OPTIONAL MATCH (app)-[:HAS_CONNECTOR]->(con:Connector)
WITH app, flows, flowCount, totalStoryPoints, avgStoryPoints,
     totalConnectorCount, totalAsyncIndicators, asyncFlows, apiExposedFlows,
     totalApiKitRoutes, totalApiKits, highRiskFlows,
     collect(DISTINCT con) AS connectorNodes

// 4) Step-level connectors across all flows
OPTIONAL MATCH (app)-[:HAS_FLOW]->(flow)-[:HAS_STEP*]->(stepConn:Step)
WHERE stepConn.category = 'connector'

// Detect batch-processing steps across all flows in the app
OPTIONAL MATCH (app)-[:HAS_FLOW]->(batchFlow:Flow)-[:HAS_STEP*]->(batchStep:Step)
WHERE batchStep.type = 'batch:job' OR batchStep.category = 'batch'

WITH app, flows, flowCount, totalStoryPoints, avgStoryPoints,
     totalConnectorCount, totalAsyncIndicators, asyncFlows, apiExposedFlows,
     totalApiKitRoutes, totalApiKits, highRiskFlows,
     connectorNodes,
     collect(DISTINCT coalesce(stepConn.name, stepConn.type)) AS stepConnectorNames,
     count(DISTINCT stepConn)                                AS stepConnectorCount,
     collect(DISTINCT batchStep)                             AS batchNodes,
     count(DISTINCT batchFlow)                               AS batchFlowCount,
     count(DISTINCT batchStep)                               AS totalBatchJobs

// 5) Database operations & configurations
OPTIONAL MATCH (app)-[:HAS_FLOW]->(flow)-[:HAS_STEP*]->(dbStep:Step)
WHERE dbStep.category = 'Database' OR dbStep.type STARTS WITH 'db:'
OPTIONAL MATCH (dbStep)-[:REFS_ON]->(cfg:Configuration)
WITH app, flowCount, totalStoryPoints, avgStoryPoints,
     totalConnectorCount, totalAsyncIndicators, asyncFlows, apiExposedFlows,
     totalApiKitRoutes, totalApiKits, highRiskFlows,
     connectorNodes, stepConnectorNames, stepConnectorCount,
     batchFlowCount, totalBatchJobs,
     collect(DISTINCT dbStep)                          AS dbNodes,
     collect(DISTINCT coalesce(cfg.configName,cfg.name)) AS dbConnectorsConfig

// 6) Final projections (lists & SQL verb detection)
WITH app, flowCount, totalStoryPoints, avgStoryPoints,
     totalConnectorCount, totalAsyncIndicators, asyncFlows, apiExposedFlows,
     totalApiKitRoutes, totalApiKits, highRiskFlows,
     stepConnectorNames, stepConnectorCount,
     batchFlowCount, totalBatchJobs,
     [c IN connectorNodes | c.name]                   AS connectorNames,
     [c IN connectorNodes | c.properties]             AS connectorProperties,
     [d IN dbNodes | coalesce(d.connectorName, d.name, d.type)] AS dbConnectors,
     [d IN dbNodes | d.properties]                    AS dbQueriesRaw,
     dbConnectorsConfig,
     [d IN dbNodes |
        CASE 
          WHEN d.properties =~ '(?is).*\\bselect\\b.*' THEN 'SELECT'
          WHEN d.properties =~ '(?is).*\\binsert\\b.*' THEN 'INSERT'
          WHEN d.properties =~ '(?is).*\\bupdate\\b.*' THEN 'UPDATE'
          WHEN d.properties =~ '(?is).*\\bdelete\\b.*' THEN 'DELETE'
          ELSE 'OTHER'
        END]                                          AS dbOperations

// 7) Return one row per application
RETURN
    app.name                  AS Application,
    flowCount                 AS FlowCount,
    totalStoryPoints          AS TotalStoryPoints,
    avgStoryPoints            AS AvgStoryPoints,
    // Story-point composition
    totalApiKitRoutes         AS ApiKitRoutes,
    totalApiKits              AS ApiKits,
    apiExposedFlows           AS ApiExposedFlows,
    // Integration / connector stats
    totalConnectorCount       AS TotalConnectors,
    stepConnectorCount        AS StepConnectorCount,
    totalBatchJobs            AS BatchJobSteps,
    batchFlowCount            AS BatchFlows,
    totalAsyncIndicators      AS AsyncIndicators,
    asyncFlows                AS AsyncFlows,
    // Risk aggregation
    highRiskFlows             AS HighRiskFlows,
    // Named lists for detailed inspection
    connectorNames            AS ConnectorNames,
    connectorProperties       AS ConnectorProperties,
    stepConnectorNames        AS StepConnectorNames,
    dbConnectors              AS DbConnectors,
    dbOperations              AS DbOperations,
    dbQueriesRaw              AS DbQueries,
    dbConnectorsConfig        AS DbConnectorsConfig
ORDER BY totalStoryPoints DESC, flowCount DESC; 